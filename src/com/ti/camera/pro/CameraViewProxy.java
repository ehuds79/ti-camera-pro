/**
 * This file was auto-generated by the Titanium Module SDK helper for Android
 * Appcelerator Titanium Mobile
 * Copyright (c) 2009-2013 by Appcelerator, Inc. All Rights Reserved.
 * Licensed under the terms of the Apache Public License
 * Please see the LICENSE included with this distribution for details.
 *
 */
package com.ti.camera.pro;

import java.io.ByteArrayOutputStream;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.IOException;
import java.text.SimpleDateFormat;
import java.util.Date;
import java.util.List;
import java.io.InputStream;
import java.io.ByteArrayInputStream;
import java.io.FileInputStream;
import java.io.OutputStream;
import org.json.JSONException;

import org.appcelerator.kroll.KrollDict;
import org.appcelerator.kroll.annotations.Kroll;
import org.appcelerator.titanium.proxy.TiViewProxy;
import org.appcelerator.titanium.util.Log;
import org.appcelerator.titanium.view.TiUIView;

import android.app.Activity;
import android.graphics.Bitmap;
import android.graphics.Bitmap.CompressFormat;
import android.graphics.BitmapFactory;
import android.graphics.Matrix;
import android.hardware.Camera;
import android.hardware.Camera.CameraInfo;
import android.hardware.Camera.AutoFocusCallback;
import android.hardware.Camera.Parameters;
import android.hardware.Camera.PictureCallback;
import android.media.ExifInterface;
import android.net.Uri;
import android.os.Environment;
import android.view.SurfaceHolder;
import android.view.SurfaceView;
import android.widget.FrameLayout;
import android.hardware.Camera.Size;

import org.json.JSONObject;
import org.json.JSONArray;

// This proxy can be created by calling CustomAndroidCamera.createExample({message: "hello world"})
@Kroll.proxy(creatableInModule=CustomAndroidCameraModule.class)
public class CameraViewProxy extends TiViewProxy
{
	// Constructor
	public CameraViewProxy()
	{
		super();
	}
	
	// Standard Debugging variables
	private static final String TAG = "CameraViewProxy";
	private static String SAVE = "camera";
	private static Integer RESOLUTION = null;
	private static Boolean FRONT_CAMERA = false;
	private static JSONArray jsonArray = null;
	private static Camera.Parameters parameters = null;
	private static Integer choosenResolution = null;
	
	private class CameraView extends TiUIView implements SurfaceHolder.Callback
	{
		private Camera camera;

		public CameraView(TiViewProxy proxy) {
			super(proxy);
			
			SurfaceView preview = new SurfaceView(proxy.getActivity());
			SurfaceHolder previewHolder = preview.getHolder();
			previewHolder.addCallback(this);
			previewHolder.setType(SurfaceHolder.SURFACE_TYPE_PUSH_BUFFERS);
			
			FrameLayout previewLayout = new FrameLayout(proxy.getActivity());
			previewLayout.addView(preview, layoutParams);
			
			setNativeView(previewLayout);
		}
		
		// added by michael browne
		// Return the current camera instance
		public Camera currentCameraInstance(){
			return this.camera;
		}
		
		@Override
		public void processProperties(KrollDict d)
		{	
			super.processProperties(d);
			
			if(d.containsKey("resolution")){
				RESOLUTION = Integer.parseInt(d.getString("resolution"));
			}
			
			if(d.containsKey("save_location")){
				SAVE = d.getString("save_location");
			}
			
			if( d.containsKey("useFrontCamera") ){
				Log.i(TAG, "Front Camera Property exists!");
				FRONT_CAMERA = d.getBoolean("useFrontCamera");
			}
		}

		@Override
		public void surfaceChanged(SurfaceHolder previewHolder, int format, int width,
				int height) {
			// TODO Auto-generated method stub
			Log.i(TAG, "Starting Preview");
			camera.startPreview();
		}

		@Override
		public void surfaceCreated(SurfaceHolder previewHolder) {
			// TODO Auto-generated method stub
			Log.i(TAG, "Opening Camera");
			try
			{
				this.camera = getCameraInstance();
				
				Log.i(TAG, "Setting Preview Display");
				camera.setPreviewDisplay(previewHolder);
				camera.setDisplayOrientation(90);
			
				Parameters cameraParams = camera.getParameters();
				// cameraParams.setPreviewSize(layoutParams.width, layoutParams.height);
				if( isAutoFocusSupported() ) cameraParams.setFocusMode(Camera.Parameters.FOCUS_MODE_AUTO);
				if( hasFlash() ) cameraParams.setFlashMode(Camera.Parameters.FLASH_MODE_AUTO);
				
				//Camera.Size pictureSize=getLowResolutionPictureSize(cameraParams);
				Camera.Size pictureSize = null;
				if(RESOLUTION!=null)
				{
					pictureSize=getCustomResolutionPictureSize(cameraParams);
					Log.i(TAG, "Custom resolution!!!!");
				}
				else
				{
					pictureSize=getLowResolutionPictureSize(cameraParams);
				}
				
				//Camera.Size pictureSize=getHighestResolutionPictureSize(cameraParams);
				cameraParams.setPictureSize(pictureSize.width, pictureSize.height);
				
				camera.setParameters(cameraParams);
			}
			catch(IOException e)
			{
				e.printStackTrace();
			}
		}

		@Override
		public void surfaceDestroyed(SurfaceHolder arg0) {
			// TODO Auto-generated method stub
			camera.release();
			camera=null;
			
		}
		
		public Camera getCameraInstance()
		{
			Camera c = null;
			try
			{
				if( FRONT_CAMERA && hasFrontCamera() )
					c = Camera.open( Camera.CameraInfo.CAMERA_FACING_FRONT );
				else
					c = Camera.open();
			}
			catch( Exception e )
			{
				Log.d(TAG, "Camera not available");
				e.printStackTrace();
			}


			
			if(c!=null && jsonArray==null)
			{
				Parameters params = c.getParameters();
				List sizes = params.getSupportedPictureSizes();

				Camera.Size result = null;
				jsonArray = new JSONArray();

				try{
					for (int i=0;i<sizes.size();i++){
				        result = (Size) sizes.get(i);
				        Log.d(TAG,"Available resolution: "+result.width+" "+result.height);
				        JSONObject obj = new JSONObject();
				        obj.put("width",result.width);
				        obj.put("height",result.height);
				        jsonArray.put(obj);
					}
					//c.release();
		    	}
		    	catch(JSONException e)
		    	{
		    		e.printStackTrace();
		    		return null;
		    	}
	    	}
	    	

			return c;
		}
	}
	
	// changed by michael browne
	private TiUIView view = null;
	private Activity act = null;
	
	@Override
	public TiUIView createView(Activity activity)
	{
		view = new CameraView(this);
		act = activity;
		view.getLayoutParams().autoFillsHeight = true;
		view.getLayoutParams().autoFillsWidth = true;
		return view;
	}

	// Handle creation options
	@Override
	public void handleCreationDict(KrollDict options)
	{
		super.handleCreationDict(options);
		
		if (options.containsKey("save_location")) {
			SAVE = options.getString("save_location");
		}
		
		if (options.containsKey("resolution")) {
			RESOLUTION = Integer.parseInt(options.getString("resolution"));
		}
	}
	
	// Added by michael browne
	@Kroll.method
	public void setSaveLocation(String location)
	{
		SAVE = location;
	}
	
	// Added by michael browne
	@Kroll.method
	public void snapPicture()
	{
		Camera cam = ((CameraView) view).currentCameraInstance();
		cam.autoFocus(mAutoFocusCallback);
		// cam.takePicture(null, null, mPicture);
	}
	
	@Kroll.method
	public String getResolutions()
	{
		/*
		Camera c = getCameraInstance();
		c.autoFocus(null);
		Parameters params = c.getParameters();
		List sizes = params.getSupportedPictureSizes();

		JSONArray jsonArray = new JSONArray();
		JSONObject object = new JSONObject();

		try{
		Camera.Size result = null;
		for (int i=0;i<sizes.size();i++){
	        result = (Size) sizes.get(i);
	        Log.d(TAG,"Available resolution: "+result.width+" "+result.height);
	        JSONObject obj = new JSONObject();
	        obj.put("width",result.width);
	        obj.put("height",result.height);
	        jsonArray.put(obj);
		}
		c.release();
		c=null;
        return jsonArray.toString();
    	}
    	catch(JSONException e)
    	{
    		e.printStackTrace();
    		return null;
    	}
    	*/

       	
       	//Camera cam = ((CameraView) view).currentCameraInstance();
       	//cam.release();
       	return jsonArray.toString();

	}

	// Added by michael browne
	private void triggerEvent( String path )
	{
		KrollDict imagePath = new KrollDict();
		
		File extFile = new File(path);
		Uri uriPath = Uri.fromFile(extFile);
		imagePath.put("path", uriPath.toString());
		
		Log.i(TAG, "Sending path back to Titanium. Image Path > "+uriPath.toString());
		
		fireEvent("picture_taken", imagePath);
	}
	
	//Added by michael browne
	private void rotatePicture( String path ){
		// Try and get the images metadata
		try {
			ExifInterface ei = new ExifInterface(path);
			
			// Get the orientation from the meta data
			int picture_orientation = ei.getAttributeInt(ExifInterface.TAG_ORIENTATION, ExifInterface.ORIENTATION_NORMAL);
			int device_orientation = act.getWindowManager().getDefaultDisplay().getOrientation();
			
			// Both give the same reading so wondering if the camera is rotated at all??
			Log.i(TAG, "Picture Orientation is "+picture_orientation);
			Log.i(TAG, "Device Orientation is "+device_orientation);
			
			doRotation(path, FRONT_CAMERA ? 270 : 90); // Just rotate 90 degrees.... may cause problems on some devices
			
			// Do the rotation depending on the orientation
			/*switch(picture_orientation){
				case ExifInterface.ORIENTATION_ROTATE_90:
					doRotation(path, 90);
					break;
				case ExifInterface.ORIENTATION_ROTATE_180:
					doRotation(path, 180);
					break;
			}*/
			
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}	
	}
	
	// Added by michael browne
	private void doRotation( String path, float rotate ){
		// Get a Bitmap representation of the image
		BitmapFactory bFactory = new BitmapFactory();
		Bitmap bmap = bFactory.decodeFile(path);
		
		// Create the matrix for rotating the bitmap
		Matrix matrix = new Matrix();
		matrix.setRotate(rotate, bmap.getWidth()/2, bmap.getHeight()/2);
		
		// Create a new version of the bitmap - but rotated
		Bitmap rotated = Bitmap.createBitmap(bmap, 0, 0, bmap.getWidth(), bmap.getHeight(), matrix, true);
		
		// Save the new bitmap to a byte array
		File rotatedFile = new File(path);
		ByteArrayOutputStream bos = new ByteArrayOutputStream();
		rotated.compress(CompressFormat.JPEG, 80, bos); // Best quality over 80
		byte[] bitmapData = bos.toByteArray();
		
		// Try to write (overwrite) the file
		try{
			FileOutputStream fos = new FileOutputStream(rotatedFile);
			fos.write(bitmapData);
			fos.close();
		} catch (FileNotFoundException e){
			Log.i(TAG, "File Not Found: "+e);
		} catch (IOException e){
			Log.i(TAG, "IO Error: "+e);
		}
		
	}
	
	private AutoFocusCallback mAutoFocusCallback = new AutoFocusCallback()
	{

		@Override
		public void onAutoFocus(boolean arg0, Camera camera) {
			// TODO Auto-generated method stub
			camera.takePicture(null, null, mPicture);
		}
		
	};
	
	// Decodes image and scales it to reduce memory consumption
	/*
	private Bitmap compressFileInputStream(FileInputStream rawFileInputStream) {
	    try {
	        // Decode image size
	        BitmapFactory.Options o = new BitmapFactory.Options();
	        o.inJustDecodeBounds = true;
	        BitmapFactory.decodeStream(rawFileInputStream, null, o);

	        // The new size we want to scale to
	        final int REQUIRED_SIZE=70;

	        // Find the correct scale value. It should be the power of 2.
	        int scale = 1;
	        while(o.outWidth / scale / 2 >= REQUIRED_SIZE && 
	              o.outHeight / scale / 2 >= REQUIRED_SIZE) {
	            scale *= 2;
	        }

	        // Decode with inSampleSize
	        BitmapFactory.Options opt = new BitmapFactory.Options();
	        opt.inSampleSize = scale;
	        return BitmapFactory.decodeStream(rawFileInputStream, null, opt);
	    } catch (FileNotFoundException e) {}
	    return null;
	};
	*/

	// Added by michael browne
	private PictureCallback mPicture = new PictureCallback()
	{

		@Override
		public void onPictureTaken(byte[] data, Camera c) {
			// TODO Auto-generated method stub
			File pictureFile = getOutputMediaFile(); //1 corresponds to MEDIA_TYPE_IMAGE
			
			if( pictureFile == null ) return;
			
			/*
			// Added by Rodrigo Pavez
			int maxSize = 1000; //816
			//mCamera.stopPreview();
		    BitmapFactory.Options opt=new BitmapFactory.Options();
		    
		    //before making an actual bitmap, check size if the bitmap's size is too large,out of memory occurs. 
		 
		    opt.inJustDecodeBounds=true;
		    BitmapFactory.decodeByteArray(data, 0, data.length,opt);
		    int srcSize=Math.max(opt.outWidth, opt.outHeight);
		    System.out.println("out w:"+opt.outWidth+" h:"+opt.outHeight);
		    
		    opt.inSampleSize=maxSize <srcSize ? (srcSize/maxSize):1;
		    
		    System.out.println("sample size "+opt.inSampleSize);
 			
 			int size =Math.min(opt.outWidth,opt.outHeight);

		    opt.inJustDecodeBounds=false;
 
	
		    Bitmap tmp=BitmapFactory.decodeByteArray(data, 0, data.length,opt);
		    
		    //Scaling and rotation
		    //loat scale=Math.max((float)maxSize/opt.outWidth,(float)maxSize/opt.outHeight);
		    //atrix matrix=new Matrix();
		    //ystem.out.println("sample out w:"+opt.outWidth+" h:"+opt.outHeight);
		    //nt size =Math.min(opt.outWidth,opt.outHeight);
		    //atrix.setRotate(90);
		    //atrix.postScale(scale, scale);
		    //Bitmap source=Bitmap.createBitmap(tmp, 0, 0 , 500, 400, matrix, true);
		    Bitmap source=Bitmap.createBitmap(tmp, 0, 0 ,opt.outWidth,opt.outHeight);
 			*/


	        // The new size we want to scale to
	        final int REQUIRED_SIZE=70;

	        // Find the correct scale value. It should be the power of 2.

	        // Decode with inSampleSize
	        BitmapFactory.Options opt = new BitmapFactory.Options();

	        int scale = 1;
	        while(opt.outWidth / scale / 2 >= REQUIRED_SIZE && 
	              opt.outHeight / scale / 2 >= REQUIRED_SIZE) {
	            scale *= 2;
	        }

	        //BitmapFactory.decodeByteArray(data, 0, data.length,opt);
	        Bitmap tmp = BitmapFactory.decodeByteArray(data, 0, data.length,opt);
	        opt.inSampleSize = scale;
	        Bitmap source=Bitmap.createBitmap(tmp, 0, 0 ,opt.outWidth,opt.outHeight);

		    try{
				OutputStream outputStream=new FileOutputStream(pictureFile);
				source.compress(CompressFormat.PNG, 0, outputStream);
				outputStream.close();
				Camera cam = ((CameraView) view).currentCameraInstance();
				cam.startPreview();
				triggerEvent(pictureFile.getPath());
			} catch (IOException e){
				Log.i(TAG, "IO Error: "+e);
			}

 			/*

			try{
				FileOutputStream fos = new FileOutputStream(pictureFile);
				//InputStream input = new ByteArrayInputStream(data);
				//Bitmap bmp = compressFileInputStream(data);
				//ByteArrayOutputStream stream = new ByteArrayOutputStream();
				//bmp.compress(Bitmap.CompressFormat.PNG, 100, stream);
				//byte[] byteArray = stream.toByteArray();
				//fos.write(data);
				source.compress(CompressFormat.JPEG, 90, outputStream);
				fos.close();
				
				// Rotate Picture
				rotatePicture(pictureFile.getPath());
				
				// Trigger 
				triggerEvent(pictureFile.getPath());
			} catch (FileNotFoundException e){
				Log.i(TAG, "File Not Found: "+e);
			} catch (IOException e){
				Log.i(TAG, "IO Error: "+e);
			}
			*/
		}
		
	};
	
	// Added by michael browne
	private static File getOutputMediaFile(){
		
		File mediaStorageDir = new File(Environment.getExternalStoragePublicDirectory(Environment.DIRECTORY_PICTURES),SAVE);
		
		if( !mediaStorageDir.exists() ){
			if( !mediaStorageDir.mkdirs()){
				Log.i("CAMERA FILE SYSTEM", "failed to create directory");
				return null;
			}
		}
		
		// Create a media file
		String timestamp = new SimpleDateFormat("yyyyMMdd_HHmmss").format(new Date());
		
		File mediaFile;
		mediaFile = new File(mediaStorageDir.getPath() + File.separator + "IMG_" + timestamp + ".jpg");
		return mediaFile;
	}
	
	
	/*
	 * Function to get a Low Resolution Picture Size
	 * Low Res defined as 720x480 pixels (are close to it)
	 * @param Camera.Parameters Parameters for the camera
	 * @return Camera.Size Best size match
	 */
	private Camera.Size getLowResolutionPictureSize(Camera.Parameters parameters){
		int idealArea = 720*480;
		int diff = Integer.MAX_VALUE;
		Camera.Size result = null;
		
		for( Camera.Size size : parameters.getSupportedPictureSizes() ){
			int area = size.width * size.height;
			if( Math.abs(idealArea - area) < diff ){
				diff = Math.abs(idealArea - area);
				result = size;
			}
		}
		
		return result;
	}
	
	private Camera.Size getHighestResolutionPictureSize(Camera.Parameters params){


		List sizes = params.getSupportedPictureSizes();
		Camera.Size result = (Size) sizes.get(0);
		Log.i(TAG, "Chosen resolution: "+result.width+" "+result.height);
		
		return result;
	}
	
	private Camera.Size getCustomResolutionPictureSize(Camera.Parameters params){


		List sizes = params.getSupportedPictureSizes();
		Camera.Size result = (Size) sizes.get(RESOLUTION);
		Log.i(TAG, "Chosen resolution: "+result.width+" "+result.height);
		
		return result;
	}
	
	/**
	 * Function to determine if flash support is available
	 * @return Boolean Flash Support
	 */
	private boolean hasFlash(){
		Camera cam = ((CameraView) view).currentCameraInstance();
		Parameters params = cam.getParameters();
	    List<String> flashModes = params.getSupportedFlashModes();
	    if(flashModes == null) {
	        return false;
	    }

	    for(String flashMode : flashModes) {
	        if(Parameters.FLASH_MODE_ON.equals(flashMode)) {
	            return true;
	        }
	    }

	    return false;
	}
	
	/**
	 * Function to determine if a front camera exists
	 * @return Boolean Front Camera Exists
	 */
	
	private boolean hasFrontCamera(){
		int numCameras= Camera.getNumberOfCameras();
		for(int i=0;i<numCameras;i++){
		    Camera.CameraInfo info = new CameraInfo();
		    Camera.getCameraInfo(i, info);
		    if(Camera.CameraInfo.CAMERA_FACING_FRONT == info.facing){
		        return true;
		    }
		}
		return false;
	}
	
	/**
	 * Function to determine if Auto Focus is supported
	 * @return Boolean Auto Focus Supported
	 */
	
	private boolean isAutoFocusSupported() {
		Camera cam = ((CameraView) view).currentCameraInstance();
		List<String> supportedFocusModes = cam.getParameters().getSupportedFocusModes();
		return supportedFocusModes != null && supportedFocusModes.contains(Camera.Parameters.FOCUS_MODE_AUTO);
	}
}